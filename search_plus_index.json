{"./":{"url":"./","title":"Introduction","keywords":"","body":" 介绍 介绍 leetcode 地址 https://leetcode.com/problemset/all/ 准备刷一道，总结一道。 可以加好友一起交流。 QQ 648917857 微信 17771420231 github 地址：https://github.com/wind-liang/leetcode 预览地址：http://leetcode.wang 知乎开设了专栏，同步更新：https://zhuanlan.zhihu.com/leetcode1024，关注后可以及时收到更新。 如果觉得对你有帮助，记得给一个 star 哦 ^ ^ "},"leetCode-1-Two-Sum.html":{"url":"leetCode-1-Two-Sum.html","title":"1. Two Sum","keywords":"","body":"1. 题目描述 （简单难度）2. 解法一3. 解法二4. 解法三5. 总结1. 题目描述 （简单难度） 给定一个数组和一个目标和，从数组中找两个数字相加等于目标和，输出这两个数字的下标。 2. 解法一 简单粗暴些，两重循环，遍历所有情况看相加是否等于目标和，如果符合直接输出。 public int[] twoSum1(int[] nums, int target) { int []ans=new int[2]; for(int i=0;i 时间复杂度：两层 for 循环，O（n²） 空间复杂度：O（1） 3. 解法二 在上边的解法中看下第二个 for 循环步骤。 for(int j=(i+1);j 我们换个理解方式： for(int j=(i+1);j 第二层 for 循环无非是遍历所有的元素，看哪个元素等于 sub ，时间复杂度为 O（n）。 有没有一种方法，不用遍历就可以找到元素里有没有等于 sub 的？ hash table ！！！ 我们可以把数组的每个元素保存为 hash 的 key，下标保存为 hash 的 value 。 这样只需判断 sub 在不在 hash 的 key 里就可以了，而此时的时间复杂度仅为 O（1）！ 需要注意的地方是，还需判断找到的元素不是当前元素，因为题目里讲一个元素只能用一次。 public int[] twoSum2(int[] nums, int target) { Map map=new HashMap<>(); for(int i=0;i 时间复杂度：比解法一少了一个 for 循环，降为 O（n） 空间复杂度：所谓的空间换时间，这里就能体现出来， 开辟了一个 hash table ，空间复杂度变为 O（n） 4. 解法三 看解法二中，两个 for 循环，他们长的一样，我们当然可以把它合起来。复杂度上不会带来什么变化，变化仅仅是不需要判断是不是当前元素了，因为当前元素还没有添加进 hash 里。 public int[] twoSum3(int[] nums, int target) { Map map=new HashMap<>(); for(int i=0;i 5. 总结 题目比较简单，毕竟暴力的方法也可以解决。唯一闪亮的点就是，时间复杂度从 O（n²）降为 O（n） 的时候，对 hash 的应用，有眼前一亮的感觉。 "},"leetCode-2-Add-Two-Numbers.html":{"url":"leetCode-2-Add-Two-Numbers.html","title":"2. Add Two Numbers","keywords":"","body":"1. 题目描述（中等难度）2. 图示3. 思路4. 代码5. 扩展6. 迭代思想7. 迭代代码8. 递归思想9. 代码1. 题目描述（中等难度） 就是两个链表表示的数相加，这样就可以实现两个很大的数相加了，无需考虑数值 int ，float 的限制了。 由于自己实现的很乱，直接按答案的讲解了。 2. 图示 链表最左边表示个位数，代表 342 + 465 =807 。 3. 思路 首先每一位相加肯定会产生进位，我们用 carry 表示。进位最大会是 1 ，因为最大的情况是无非是 9 + 9 + 1 = 19 ，也就是两个最大的数相加，再加进位，这样最大是 19 ，不会产生进位 2 。下边是伪代码。 初始化一个节点的头，dummy head ，但是这个头不存储数字。并且将 curr 指向它。 初始化进位 carry 为 0 。 初始化 p 和 q 分别为给定的两个链表 l1 和 l2 的头，也就是个位。 循环，直到 l1 和 l2 全部到达 null 。 设置 x 为 p 节点的值，如果 p 已经到达了 null，设置 x 为 0 。 设置 y 为 q 节点的值，如果 q 已经到达了 null，设置 y 为 0 。 设置 sum = x + y + carry 。 更新 carry = sum / 10 。 创建一个值为 sum mod 10 的节点，并将 curr 的 next 指向它，同时 curr 指向变为当前的新节点。 向前移动 p 和 q 。 判断 carry 是否等于 1 ，如果等于 1 ，在链表末尾增加一个为 1 的节点。 返回 dummy head 的 next ，也就是个位数开始的地方。 初始化的节点 dummy head 没有存储值，最后返回 dummy head 的 next 。这样的好处是不用单独对 head 进行判断改变值。也就是如果一开始的 head 就是代表个位数，那么开始初始化的时候并不知道它的值是多少，所以还需要在进入循环前单独对它进行值的更正，不能像现在一样只用一个循环简洁。 4. 代码 class ListNode { int val; ListNode next; ListNode(int x) { val = x; } } public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummyHead = new ListNode(0); ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q != null) { int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; } if (carry > 0) { curr.next = new ListNode(carry); } return dummyHead.next; } 时间复杂度：O（max（m，n）），m 和 n 代表 l1 和 l2 的长度。 空间复杂度：O（max（m，n）），m 和 n 代表 l1 和 l2 的长度。而其实新的 List 最大长度是 O（max（m，n））+ 1，因为我们的 head 没有存储值。 5. 扩展 如果链表存储的顺序反过来怎么办？ 我首先想到的是链表先逆序计算，然后将结果再逆序呗，这就转换到我们之前的情况了。不知道还有没有其他的解法。下边分析下单链表逆序的思路。 6. 迭代思想 首先看一下原链表。 总共需要添加两个指针，pre 和 next。 初始化 pre 指向 NULL 。 然后就是迭代的步骤，总共四步，顺序一步都不能错。 next 指向 head 的 next ，防止原链表丢失 head 的 next 从原来链表脱离，指向 pre 。 pre 指向 head head 指向 next 一次迭代就完成了，如果再进行一次迭代就变成下边的样子。 可以看到整个过程无非是把旧链表的 head 取下来，添加的新的链表上。代码怎么写呢？ next = head -> next; //保存 head 的 next , 以防取下 head 后丢失 head -> next = pre; //将 head 从原链表取下来，添加到新链表上 pre = head;// pre 右移 head = next; // head 右移 接下来就是停止条件了，我们再进行一次循环。 可以发现当 head 或者 next 指向 null 的时候，我们就可以停止了。此时将 pre 返回，便是逆序了的链表了。 7. 迭代代码 public ListNode reverseList(ListNode head){ if(head==null) return null; ListNode pre=null; ListNode next; while(head!=null){ next=head.next; head.next=pre; pre=head; head=next; } return pre; } 8. 递归思想 首先假设我们实现了将单链表逆序的函数，ListNode reverseListRecursion(ListNode head) ，传入链表头，返回逆序后的链表头。 接着我们确定如何把问题一步一步的化小，我们可以这样想。 把 head 结点拿出来，剩下的部分我们调用函数 reverseListRecursion ，这样剩下的部分就逆序了，接着我们把 head 结点放到新链表的尾部就可以了。这就是整个递归的思想了。 ​ head 结点拿出来 剩余部分调用逆序函数 reverseListRecursion ，并得到了 newhead 将 2 指向 1 ，1 指向 null，将 newhead 返回即可。 找到递归出口 当然就是如果结点的个数是一个，那么逆序的话还是它本身，直接 return 就够了。怎么判断结点个数是不是一个呢？它的 next 等于 null 就说明是一个了。但如果传进来的本身就是 null，那么直接找它的 next 会报错，所以先判断传进来的是不是 null ，如果是，也是直接返回就可以了。 9. 代码 public ListNode reverseListRecursion(ListNode head){ ListNode newHead; if(head==null||head.next==null ){ return head; } newHead=reverseListRecursion(head.next); //head.next 作为剩余部分的头指针 head.next.next=head; //head.next 代表新链表的尾，将它的 next 置为 head，就是将 head 加到最后了。 head.next=null; return newHead; } "}}