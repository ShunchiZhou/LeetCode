{"./":{"url":"./","title":"Introduction","keywords":"","body":" 介绍 介绍 leetcode 地址 https://leetcode.com/problemset/all/ 准备刷一道，总结一道。 可以加好友一起交流。 QQ 648917857 微信 17771420231 github 地址：https://github.com/wind-liang/leetcode 预览地址：http://leetcode.wang 知乎开设了专栏，同步更新：https://zhuanlan.zhihu.com/leetcode1024，关注后可以及时收到更新。 如果觉得对你有帮助，记得给一个 star 哦 ^ ^ "},"leetCode-1-Two-Sum.html":{"url":"leetCode-1-Two-Sum.html","title":"1. Two Sum","keywords":"","body":"1. 题目描述 （简单难度）2. 解法一3. 解法二4. 解法三5. 总结1. 题目描述 （简单难度） 给定一个数组和一个目标和，从数组中找两个数字相加等于目标和，输出这两个数字的下标。 2. 解法一 简单粗暴些，两重循环，遍历所有情况看相加是否等于目标和，如果符合直接输出。 public int[] twoSum1(int[] nums, int target) { int []ans=new int[2]; for(int i=0;i 时间复杂度：两层 for 循环，O（n²） 空间复杂度：O（1） 3. 解法二 在上边的解法中看下第二个 for 循环步骤。 for(int j=(i+1);j 我们换个理解方式： for(int j=(i+1);j 第二层 for 循环无非是遍历所有的元素，看哪个元素等于 sub ，时间复杂度为 O（n）。 有没有一种方法，不用遍历就可以找到元素里有没有等于 sub 的？ hash table ！！！ 我们可以把数组的每个元素保存为 hash 的 key，下标保存为 hash 的 value 。 这样只需判断 sub 在不在 hash 的 key 里就可以了，而此时的时间复杂度仅为 O（1）！ 需要注意的地方是，还需判断找到的元素不是当前元素，因为题目里讲一个元素只能用一次。 public int[] twoSum2(int[] nums, int target) { Map map=new HashMap<>(); for(int i=0;i 时间复杂度：比解法一少了一个 for 循环，降为 O（n） 空间复杂度：所谓的空间换时间，这里就能体现出来， 开辟了一个 hash table ，空间复杂度变为 O（n） 4. 解法三 看解法二中，两个 for 循环，他们长的一样，我们当然可以把它合起来。复杂度上不会带来什么变化，变化仅仅是不需要判断是不是当前元素了，因为当前元素还没有添加进 hash 里。 public int[] twoSum3(int[] nums, int target) { Map map=new HashMap<>(); for(int i=0;i 5. 总结 题目比较简单，毕竟暴力的方法也可以解决。唯一闪亮的点就是，时间复杂度从 O（n²）降为 O（n） 的时候，对 hash 的应用，有眼前一亮的感觉。 "},"leetCode-2-Add-Two-Numbers.html":{"url":"leetCode-2-Add-Two-Numbers.html","title":"2. Add Two Numbers","keywords":"","body":"1. 题目描述（中等难度）2. 图示3. 思路4. 代码5. 扩展6. 迭代思想7. 迭代代码8. 递归思想9. 代码1. 题目描述（中等难度） 就是两个链表表示的数相加，这样就可以实现两个很大的数相加了，无需考虑数值 int ，float 的限制了。 由于自己实现的很乱，直接按答案的讲解了。 2. 图示 链表最左边表示个位数，代表 342 + 465 =807 。 3. 思路 首先每一位相加肯定会产生进位，我们用 carry 表示。进位最大会是 1 ，因为最大的情况是无非是 9 + 9 + 1 = 19 ，也就是两个最大的数相加，再加进位，这样最大是 19 ，不会产生进位 2 。下边是伪代码。 初始化一个节点的头，dummy head ，但是这个头不存储数字。并且将 curr 指向它。 初始化进位 carry 为 0 。 初始化 p 和 q 分别为给定的两个链表 l1 和 l2 的头，也就是个位。 循环，直到 l1 和 l2 全部到达 null 。 设置 x 为 p 节点的值，如果 p 已经到达了 null，设置 x 为 0 。 设置 y 为 q 节点的值，如果 q 已经到达了 null，设置 y 为 0 。 设置 sum = x + y + carry 。 更新 carry = sum / 10 。 创建一个值为 sum mod 10 的节点，并将 curr 的 next 指向它，同时 curr 指向变为当前的新节点。 向前移动 p 和 q 。 判断 carry 是否等于 1 ，如果等于 1 ，在链表末尾增加一个为 1 的节点。 返回 dummy head 的 next ，也就是个位数开始的地方。 初始化的节点 dummy head 没有存储值，最后返回 dummy head 的 next 。这样的好处是不用单独对 head 进行判断改变值。也就是如果一开始的 head 就是代表个位数，那么开始初始化的时候并不知道它的值是多少，所以还需要在进入循环前单独对它进行值的更正，不能像现在一样只用一个循环简洁。 4. 代码 class ListNode { int val; ListNode next; ListNode(int x) { val = x; } } public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummyHead = new ListNode(0); ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q != null) { int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; } if (carry > 0) { curr.next = new ListNode(carry); } return dummyHead.next; } 时间复杂度：O（max（m，n）），m 和 n 代表 l1 和 l2 的长度。 空间复杂度：O（max（m，n）），m 和 n 代表 l1 和 l2 的长度。而其实新的 List 最大长度是 O（max（m，n））+ 1，因为我们的 head 没有存储值。 5. 扩展 如果链表存储的顺序反过来怎么办？ 我首先想到的是链表先逆序计算，然后将结果再逆序呗，这就转换到我们之前的情况了。不知道还有没有其他的解法。下边分析下单链表逆序的思路。 6. 迭代思想 首先看一下原链表。 总共需要添加两个指针，pre 和 next。 初始化 pre 指向 NULL 。 然后就是迭代的步骤，总共四步，顺序一步都不能错。 next 指向 head 的 next ，防止原链表丢失 head 的 next 从原来链表脱离，指向 pre 。 pre 指向 head head 指向 next 一次迭代就完成了，如果再进行一次迭代就变成下边的样子。 可以看到整个过程无非是把旧链表的 head 取下来，添加的新的链表上。代码怎么写呢？ next = head -> next; //保存 head 的 next , 以防取下 head 后丢失 head -> next = pre; //将 head 从原链表取下来，添加到新链表上 pre = head;// pre 右移 head = next; // head 右移 接下来就是停止条件了，我们再进行一次循环。 可以发现当 head 或者 next 指向 null 的时候，我们就可以停止了。此时将 pre 返回，便是逆序了的链表了。 7. 迭代代码 public ListNode reverseList(ListNode head){ if(head==null) return null; ListNode pre=null; ListNode next; while(head!=null){ next=head.next; head.next=pre; pre=head; head=next; } return pre; } 8. 递归思想 首先假设我们实现了将单链表逆序的函数，ListNode reverseListRecursion(ListNode head) ，传入链表头，返回逆序后的链表头。 接着我们确定如何把问题一步一步的化小，我们可以这样想。 把 head 结点拿出来，剩下的部分我们调用函数 reverseListRecursion ，这样剩下的部分就逆序了，接着我们把 head 结点放到新链表的尾部就可以了。这就是整个递归的思想了。 ​ head 结点拿出来 剩余部分调用逆序函数 reverseListRecursion ，并得到了 newhead 将 2 指向 1 ，1 指向 null，将 newhead 返回即可。 找到递归出口 当然就是如果结点的个数是一个，那么逆序的话还是它本身，直接 return 就够了。怎么判断结点个数是不是一个呢？它的 next 等于 null 就说明是一个了。但如果传进来的本身就是 null，那么直接找它的 next 会报错，所以先判断传进来的是不是 null ，如果是，也是直接返回就可以了。 9. 代码 public ListNode reverseListRecursion(ListNode head){ ListNode newHead; if(head==null||head.next==null ){ return head; } newHead=reverseListRecursion(head.next); //head.next 作为剩余部分的头指针 head.next.next=head; //head.next 代表新链表的尾，将它的 next 置为 head，就是将 head 加到最后了。 head.next=null; return newHead; } "},"leetCode-3-Longest-Substring-Without-Repeating-Characters.html":{"url":"leetCode-3-Longest-Substring-Without-Repeating-Characters.html","title":"3. Longest Substring Without Repeating Characters","keywords":"","body":"1. 题目描述（中等难度）2. 解法一3. 解法二4. 解法三5. 解法四6. 总结1. 题目描述（中等难度） 给定一个字符串，找到没有重复字符的最长子串，返回它的长度。 2. 解法一 简单粗暴些，找一个最长子串，那么我们用两个循环穷举所有子串，然后再用一个函数判断该子串中有没有重复的字符。 public int lengthOfLongestSubstring(String s) { int n = s.length(); int ans = 0;//保存当前得到满足条件的子串的最大值 for (int i = 0; i set = new HashSet<>();//初始化 hash set for (int i = start; i 时间复杂度：两个循环，加上判断子串满足不满足条件的函数中的循环，O（n³）。 空间复杂度：使用了一个 set，判断子串中有没有重复的字符。由于 set 中没有重复的字符，所以最长就是整个字符集，假设字符集的大小为 m ，那么 set 最长就是 m 。另一方面，如果字符串的长度小于 m ，是 n 。那么 set 最长也就是 n 了。综上，空间复杂度为 O（min（m，n））。 3. 解法二 遗憾的是上边的算法没有通过 leetCode，时间复杂度太大，造成了超时。我们怎么来优化一下呢？ 上边的算法中，我们假设当 i 取 0 的时候， j 取 1，判断字符串 str[0,1) 中有没有重复的字符。 j 取 2，判断字符串 str[0,2) 中有没有重复的字符。 j 取 3，判断字符串 str[0,3) 中有没有重复的字符。 j 取 4，判断字符串 str[0,4) 中有没有重复的字符。 做了很多重复的工作，因为如果 str[0,3) 中没有重复的字符，我们不需要再判断整个字符串 str[0,4) 中有没有重复的字符，而只需要判断 str[3] 在不在 str[0,3) 中，不在的话，就表明 str[0,4) 中没有重复的字符。 如果在的话，那么 str[0,5) ，str[0,6) ，str[0,7) 一定有重复的字符，所以此时后边的 j 也不需要继续增加了。i ++ 进入下次的循环就可以了。 此外，我们的 j 也不需要取 j + 1，而只需要从当前的 j 开始就可以了。 综上，其实整个关于 j 的循环我们完全可以去掉了，此时可以理解变成了一个「滑动窗口」。 整体就是橘色窗口在依次向右移动。 判断一个字符在不在字符串中，我们需要可以遍历整个字符串，遍历需要的时间复杂度就是 O（n），加上最外层的 i 的循环，总体复杂度就是 O（n²）。我们可以继续优化，判断字符在不在一个字符串，我们可以将已有的字符串存到 Hash 里，这样的时间复杂度是 O（1），总的时间复杂度就变成了 O（n）。 public class Solution { public int lengthOfLongestSubstring(String s) { int n = s.length(); Set set = new HashSet<>(); int ans = 0, i = 0, j = 0; while (i 时间复杂度：在最坏的情况下，while 循环中的语句会执行 2n 次，例如 abcdefgg，开始的时候 j 一直后移直到到达第二个 g 的时候固定不变 ，然后 i 开始一直后移直到 n ，所以总共执行了 2n 次，时间复杂度为 O（n）。 空间复杂度：和上边的类似，需要一个 Hash 保存子串，所以是 O（min（m，n））。 4. 解法三 继续优化，我们看上边的算法的一种情况。 当 j 指向的 c 存在于前边的子串 abcd 中，此时 i 向前移到 b ,此时子串中仍然含有 c，还得继续移动，所以这里其实可以优化。我们可以一步到位，直接移动到子串 c 的位置的下一位！ 实现这样的话，我们将 set 改为 map ，将字符存为 key ，将对应的下标存到 value 里就实现了。 public class Solution { public int lengthOfLongestSubstring(String s) { int n = s.length(), ans = 0; Map map = new HashMap<>(); for (int j = 0, i = 0; j 与解法二相比 由于采取了 i 跳跃的形式，所以 map 之前存的字符没有进行 remove ，所以 if 语句中进行了Math.max ( map.get ( s.charAt ( j ) ) , i )，要确认得到的下标不是 i 前边的。 还有个不同之处是 j 每次循环都进行了自加 1 ，因为 i 的跳跃已经保证了 str[ i , j] 内没有重复的字符串，所以 j 直接可以加 1 。而解法二中，要保持 j 的位置不变，因为不知道和 j 重复的字符在哪个位置。 最后个不同之处是， ans 在每次循环中都进行更新，因为 ans 更新前 i 都进行了更新，已经保证了当前的子串符合条件，所以可以更新 ans 。而解法二中，只有当当前的子串不包含当前的字符时，才进行更新。 时间复杂度：我们将 2n 优化到了 n ，但最终还是和之前一样，O（n）。 空间复杂度：也是一样的，O（min（m，n)）。 5. 解法四 和解法三思路一样，区别的地方在于，我们不用 Hash ，而是直接用数组，字符的 ASCII 码值作为数组的下标，数组存储该字符所在字符串的位置。适用于字符集比较小的情况，因为我们会直接开辟和字符集等大的数组。 public class Solution { public int lengthOfLongestSubstring(String s) { int n = s.length(), ans = 0; int[] index = new int[128]; for (int j = 0, i = 0; j 和解法 3 不同的地方在于，没有了 if 的判断，因为如果 index[ s.charAt ( j ) ] 不存在的话，它的值会是 0 ，对最终结果不会影响。 时间复杂度：O（n）。 空间复杂度：O（m），m 代表字符集的大小。这次不论原字符串多小，都会利用这么大的空间。 6. 总结 综上，我们一步一步的寻求可优化的地方，对算法进行了优化。又加深了 Hash 的应用，以及利用数组巧妙的实现了 Hash 的作用。 "}}