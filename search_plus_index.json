{"./":{"url":"./","title":"Introduction","keywords":"","body":" 介绍 介绍 leetcode 地址: https://leetcode.com/problemset/all/ LeetCode 刷题 + 算法总结 personal blog：https://shunchizhou.com "},"leetCode-55-Jump-Game.html":{"url":"leetCode-55-Jump-Game.html","title":"55. Jump Game","keywords":"","body":" Description(medium） Approach 1: Backtracking Conclusion Description(medium） Approach 1: Backtracking This is the inefficient solution where we try every single jump pattern that takes us from the first position to the last. We start from the first position and jump to every index that is reachable. We repeat the process until last index is reached. When stuck, backtrack. class Solution { public boolean canJumpFromPosition(int position, int[] nums) { if (position == nums.length - 1) { return true; } int furthestJump = Math.min(position + nums[position], nums.length - 1); for (int nextPosition = position + 1; nextPosition Complexity Analysis Time complexity: O(2^n). There are n²(upper bound) ways of jumping from the first position to the last, where nn is the length of array nums. For a complete proof, please refer to Appendix A. Space complexity: O(n). Recursion requires additional memory for the stack frames. Conclusion "}}