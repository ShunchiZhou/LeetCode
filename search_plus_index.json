{"./":{"url":"./","title":"Introduction","keywords":"","body":" 介绍 介绍 leetcode 地址: https://leetcode.com/problemset/all/ LeetCode 刷题 + 算法总结 personal blog：https://shunchizhou.com "},"Backtracking-N-Queen-Problem.html":{"url":"Backtracking-N-Queen-Problem.html","title":"1. N Queens Problem","keywords":"","body":"Input: The size of a chess board. Generally, it is 8. as (8 x 8 is the size of a normal chess board.) Output: All the possible boardrixes that represent in which row and column the N Queens can be placed. If the solution does not exist, it will return false. 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 In this output, the value 1 indicates the correct place for the queens. The 0 denotes the blank spaces on the chess board. import java.util.Arrays; class NQueen { // N x N chessboard public static final int N = 8; // Function to check if two queens threaten each other or not static boolean isSafe(int board[][], int r, int c) { // return false if two queens share the same column for (int i = 0; i = 0 && j >= 0; i--, j--) if (board[i][j] == 1) return false; // return false if two queens share the same / diagonal for (int i = r, j = c; i >= 0 && j "},"Backtracking-Sudoku.html":{"url":"Backtracking-Sudoku.html","title":"8. Sudoku","keywords":"","body":"Sudoku is a 9x9 matrix filled with numbers 1 to 9 in such a way that every row, column and sub-matrix (3x3) has each of the digits from 1 to 9. We are provided with a partially filled 9x9 matrix and have to fill every remaining cell in it. You can see that every row, column, and sub-matrix (3x3) contains each digit from 1 to 9. Thus, we can also conclude that a Sudoku is considered wrongly filled if it satisfies any of these criteria: Any row contains the same number more than once. Any column contains the same number more than once. Any 3x3 sub-matrix has the same number more than once. In backtracking, we first start with a sub-solution and if this sub-solution doesn't give us a correct final answer, then we just come back and change our sub-solution. We are going to solve our Sudoku in a similar way. The steps which we will follow are: If there are no unallocated cells, then the Sudoku is already solved. We will just return true. Or else, we will fill an unallocated cell with a digit between 1 to 9 so that there are no conflicts in any of the rows, columns, or the 3x3 sub-matrices. Now, we will try to fill the next unallocated cell and if this happens successfully, then we will return true. Else, we will come back and change the digit we used to fill the cell. If there is no digit which fulfills the need, then we will just return false as there is no solution of this Sudoku. class Sudoku { private static final int SIZE = 9; private static int[][] matrix = { {6,5,0,8,7,3,0,9,0}, {0,0,3,2,5,0,0,0,8}, {9,8,0,1,0,4,3,5,7}, {1,0,5,0,0,0,0,0,0}, {4,0,0,0,0,0,0,0,2}, {0,0,0,0,0,0,5,0,3}, {5,7,8,3,0,1,0,2,6}, {2,0,0,0,4,8,9,0,0}, {0,9,0,6,2,5,0,8,1} }; private static void printSudoku() { for(int i=0;i "},"leetCode-55-Jump-Game.html":{"url":"leetCode-55-Jump-Game.html","title":"55. Jump Game","keywords":"","body":" Approach 1: Backtracking Conclusion Approach 1: Backtracking This is the inefficient solution where we try every single jump pattern that takes us from the first position to the last. We start from the first position and jump to every index that is reachable. We repeat the process until last index is reached. When stuck, backtrack. class Solution { public boolean canJumpFromPosition(int position, int[] nums) { if (position == nums.length - 1) { return true; } int furthestJump = Math.min(position + nums[position], nums.length - 1); for (int nextPosition = position + 1; nextPosition Time complexity: O(2n). There are 2n(upper bound) ways of jumping from the first position to the last, where n is the length of array nums. For a complete proof, please refer to Appendix A. Space complexity: O(n). Recursion requires additional memory for the stack frames. Conclusion "}}