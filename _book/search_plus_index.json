{"./":{"url":"./","title":"Introduction","keywords":"","body":" 介绍 介绍 leetcode 地址: https://leetcode.com/problemset/all/ LeetCode 刷题 + 算法总结 personal blog：https://shunchizhou.com "},"Backtracking-N-Queen-Problem.html":{"url":"Backtracking-N-Queen-Problem.html","title":"1. N Queens Problem","keywords":"","body":"Input: The size of a chess board. Generally, it is 8. as (8 x 8 is the size of a normal chess board.) Output: All the possible matrixes that represent in which row and column the N Queens can be placed. If the solution does not exist, it will return false. 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 In this output, the value 1 indicates the correct place for the queens. The 0 denotes the blank spaces on the chess board. import java.util.Arrays; class NQueen { // N x N chessboard public static final int N = 8; // Function to check if two queens threaten each other or not static boolean isSafe(int board[][], int r, int c) { // return false if two queens share the same column for (int i = 0; i = 0 && j >= 0; i--, j--) if (board[i][j] == 1) return false; // return false if two queens share the same / diagonal for (int i = r, j = c; i >= 0 && j "},"Backtracking-Sudoku.html":{"url":"Backtracking-Sudoku.html","title":"8. Sudoku","keywords":"","body":"Sudoku is a 9x9 matrix filled with numbers 1 to 9 in such a way that every row, column and sub-matrix (3x3) has each of the digits from 1 to 9. We are provided with a partially filled 9x9 matrix and have to fill every remaining cell in it. You can see that every row, column, and sub-matrix (3x3) contains each digit from 1 to 9. Thus, we can also conclude that a Sudoku is considered wrongly filled if it satisfies any of these criteria: Any row contains the same number more than once. Any column contains the same number more than once. Any 3x3 sub-matrix has the same number more than once. In backtracking, we first start with a sub-solution and if this sub-solution doesn't give us a correct final answer, then we just come back and change our sub-solution. We are going to solve our Sudoku in a similar way. The steps which we will follow are: If there are no unallocated cells, then the Sudoku is already solved. We will just return true. Or else, we will fill an unallocated cell with a digit between 1 to 9 so that there are no conflicts in any of the rows, columns, or the 3x3 sub-matrices. Now, we will try to fill the next unallocated cell and if this happens successfully, then we will return true. Else, we will come back and change the digit we used to fill the cell. If there is no digit which fulfills the need, then we will just return false as there is no solution of this Sudoku. class Sudoku { private static final int SIZE = 9; private static int[][] matrix = { {6,5,0,8,7,3,0,9,0}, {0,0,3,2,5,0,0,0,8}, {9,8,0,1,0,4,3,5,7}, {1,0,5,0,0,0,0,0,0}, {4,0,0,0,0,0,0,0,2}, {0,0,0,0,0,0,5,0,3}, {5,7,8,3,0,1,0,2,6}, {2,0,0,0,4,8,9,0,0}, {0,9,0,6,2,5,0,8,1} }; private static void printSudoku() { for(int i=0;i "},"leetCode-55-Jump-Game.html":{"url":"leetCode-55-Jump-Game.html","title":"55. Jump Game","keywords":"","body":" Approach 1: Backtracking Approach 2: Dynamic Programming Top-down Approach 3: Dynamic Programming Bottom-up Approach 4: Greedy Conclusion Approach 1: Backtracking This is the inefficient solution where we try every single jump pattern that takes us from the first position to the last. We start from the first position and jump to every index that is reachable. We repeat the process until last index is reached. When stuck, backtrack. class Solution { public boolean canJumpFromPosition(int position, int[] nums) { if (position == nums.length - 1) { return true; } int furthestJump = Math.min(position + nums[position], nums.length - 1); for (int nextPosition = position + 1; nextPosition Time complexity: O(2n). There are 2n(upper bound) ways of jumping from the first position to the last, where n is the length of array nums. For a complete proof, please refer to Appendix A. Space complexity: O(n). Recursion requires additional memory for the stack frames. Approach 2: Dynamic Programming Top-down import java.util.*; enum Index { GOOD, BAD, UNKNOWN } class Solution { static Index[] memo; public boolean canJumpFromPosition(int position, int[] nums) { if (memo[position] != Index.UNKNOWN) { return memo[position] == Index.GOOD ? true : false; } int furthestJump = Math.min(position + nums[position], nums.length - 1); for (int nextPosition = position + 1; nextPosition Approach 3: Dynamic Programming Bottom-up import java.util.*; enum Index { GOOD, BAD, UNKNOWN } class Solution { public boolean canJump(int[] nums) { Index[] memo = new Index[nums.length]; for (int i = 0; i = 0; i--) { int furthestJump = Math.min(i + nums[i], nums.length - 1); for (int j = i + 1; j Approach 4: Greedy class Solution { public boolean canJump(int[] nums) { int lastPos = nums.length - 1; for (int i = nums.length - 1; i >= 0; i--) { if (i + nums[i] >= lastPos) { lastPos = i; } } return lastPos == 0; } public static void main(String[] args) { int[] nums={2, 4, 2, 1, 0, 2, 0}; System.out.println(new Solution().canJump(nums)); } } Conclusion The question left unanswered is how should one approach such a question in an interview scenario. I would say \"it depends\". The perfect solution is cleaner and shorter than all the other versions, but it might not be so straightforward to figure out. The (recursive) backtracking is the easiest to figure out, so it is worth mentioning it verbally while warming up for the tougher challenge. It might be that your interviewer actually wants to see that solution, but if not, mention that there might be a dynamic programming solution and try to think how could you use a memoization table. If you figure it out and the interviewer wants you to go for the top-down approach, it will not generally be time to think of the bottom-up version, but I would always mention the advantages of this technique as a final thought in the interview. Most people are stuck when converting from top-down Dynamic Programming (expressed naturally in recursion) to bottom-up. Practicing similar problems will help bridge this gap. "},"leetCode-61-Rotate-List.html":{"url":"leetCode-61-Rotate-List.html","title":"61. Rotate List","keywords":"","body":" Approach 1 Approach 1 // Definition for singly-linked list. class ListNode { int val; ListNode next; ListNode(int x) { val = x; } } class Solution { public ListNode rotateRight(ListNode head, int k) { //base cases if (head==null) return null; // close the linked list into the ring int count=1; ListNode p1=head; while (p1.next!=null) { count++; p1=p1.next; } p1.next=head; p1=p1.next; int pos=count-k%count; if (pos==count) { return head; } while (pos>1) { pos--; p1=p1.next; } ListNode newHead=p1.next; p1.next=null; return newHead; } } class slList{ public static void main(String[] args) { ListNode head=new ListNode(3); ListNode dummyHead=head; head.next=new ListNode(2); head=head.next; head.next=new ListNode(1); head=head.next; head.next=new ListNode(0); head=head.next; head.next=null; ListNode newHead=new Solution().rotateRight(dummyHead, 1); while (newHead!=null) { System.out.println(newHead.val); newHead=newHead.next; } } } "},"leetCode-62-Unique-Paths.html":{"url":"leetCode-62-Unique-Paths.html","title":"62. Unique Paths","keywords":"","body":" Approach 1 Approach 1 "},"leetCode-63-Unique-Paths-II.html":{"url":"leetCode-63-Unique-Paths-II.html","title":"63. Unique Paths II","keywords":"","body":" Approach 1 Approach 1 "},"leetCode-66-Plus-One.html":{"url":"leetCode-66-Plus-One.html","title":"66. Plus One","keywords":"","body":" Approach 1 Approach 1 class Solution { public int[] plusOne(int[] digits) { int n=digits.length; int carry=(digits[n-1]+1)/10; digits[n-1]=(digits[n-1]+1)%10; for(int i=n-2;i>=0;i--){ int tmp=digits[i]; digits[i]=(tmp+carry)%10; carry=(tmp+carry)/10; } if(carry!=0){ int[] res=new int[n+1]; res[0]=1; return res; } return digits; } } "},"leetCode-67-Add-Binary.html":{"url":"leetCode-67-Add-Binary.html","title":"67. Add Binary","keywords":"","body":" Approach 1 Approach 1 class Solution { public String addBinary(String a, String b) { int n=a.length()-1; int m=b.length()-1; int carry=0; String res=\"\"; while(n>=0||m>=0||carry==1){ int tmp=(n>=0?a.charAt(n)-'0':0)+(m>=0?b.charAt(m)-'0':0)+carry; carry=tmp/2; res=(char)tmp%2+res; n--;m--; } return res; } } "},"leetCode-69-Sqrt.html":{"url":"leetCode-69-Sqrt.html","title":"69. Sqrt(x)","keywords":"","body":" Approach 1 Approach 2 Approach 1 class Solution { public static int mySqrt(int x) { int i=0; while(i*i=0){ i++; } if(i*i==x) return i; return i-1; } } Approach 2 class Solution { public static int mySqrt(int x) { if(x==0) return 0; int left=1,right=x/2; if(left>=right) return left; while(true){ int i=left+(right-left)/2; if(i // This is a hello world program for C. #include int main(){ printf(\"Hello World!\"); return 1; } "}}